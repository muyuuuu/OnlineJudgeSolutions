### 797 题，所有可能的路径

这是我做图题目的第一题，还是那句话，不要陷入递归的细节。不过这道题不同的是，使用了一个结果存储了所有可能结果，不像之前的树那样，对每一个节点创建结果。

首先从 0 开始遍历：

- base case：因为这是无环图，遍历到最后一个节点，就说明找完了，添加结果
- 否则，访问 0 节点指向哪个节点，然后添加这个节点，在递归调用遍历节点的函数
- 在一条路径查找完毕后，应该 pop\_back, 如第一次查找的路径是 0 1 2 3，那么回溯的时候就是 0 1 2 这样去查找。

### 207 题，有向图环检测

个人建议使用深度优先遍历来解决问题。首先使用二维 vector 来初始化数组，创建 visited 来存储一个节点是否被访问过，0 表示没有被访问，1 表示被访问过，2 表示这个节点所在的任何边都没问题。

注意，遍历前判断：当前节点是否没有被访问，如果被访问过，就不访问了。访问期间节点的值为1，表示节点被访问，可能还会被访问；访问结束后，节点的值为 2，表示这个节点所在的边没问题，不存在有向环。

如 A 节点被访问过，那么遍历时的入口节点就忽略 A；如果从 B 开始遍历，发现 A 被访问过了且取值不为 2，就说明这里是有环的图。

### 210 题，可能的路径

这个比第一题简单些，只用求一条路径。此类拓朴排序的题目我建议使用 dfs 算法：

1. visited 数组有三个取值，0 表示可以遍历，1表示正在遍历，2 表示遍历完成。需要理解的是，并非遍历过就不能在遍历了。
2. 重点就是，在遍历完后，做一些什么。如果是求全部路径，那么就需要回退和判断是否遍历完成，如果是求单个可行路径，那么就不用。
