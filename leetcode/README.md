# 题解整理

注：这里的题解会很粗糙

## 哈希

1. 第 1 题，寻找目标序列中两数之和等于目标值。暴力可以通过，但不好。使用哈希，空间换时间。第一次遍历数组，标记每个数的位置。第二次遍历数组，看看那个数在不在。
2. 第 3 题，寻找最长的子序列。哈希 + 滑动窗口。利用 map，标记一个字符是否出现过。使用滑动窗口 start 和 end，end 向后移动。遇到重复，更新 start；不重复，标记当前符号的位置。最后结果是 end - start + 1。
3. 第 136 题，查找序列中只出现一次的数。通解，使用哈希。适用于此题的解，因为其它数据都出现了不多不少整整两次，所以可以使用异或运算。因为 `b ⊕ a ⊕ a = b, a ⊕ a = 0`，所以只需在线性的空间内完成。
4. 第 347 题，寻找最大的 K 个数。使用 map 记录元素出现次数。将值和次数放入 vector，对值排序。而后输出前 K 个值的 idx。
5. 第 187 题，寻找出现多次的子序列。使用 map 能解决。但需要注意的是，滑动窗口的长度能取等号，子串取法，以及 if else 的顺序和标记一个字串出现过第二次。
6. 第 447 题，回旋标的数量。两次遍历，记录于当前点的距离，而后结果是 `res * (res-1)`。不要求排序，所以建议使用 unordered_map，而不是 map。
7. 第 451 题，给定一个字符串，请将字符串里的字符按照出现的频率降序排列。`tree -> eert`，首先无序 map 记录每个元素出现的次数。构建一个结构体，将元素、元素出现的次数放入一个向量中，对向量排序。然后输出。此题可以理解固定模板。
8. 第 554 题，砖墙。应该使用 map 记录每个缝隙出现的次数，而不是使用数组，因为数组会内存爆炸，且要逐个遍历。
9. 第 981 题，基于时间的键值存储。创建二级哈希表，key->timestamp->value，查找的时候先找 key，没有返回空。如果有，timestamp->value 使用有序 map，upper_bound 方法查找即可。没有找到的情况是：`m.upper_bound(key) == m.begin()`，返回空；如果找到，返回上一个元素的 second。
10. 第 939 题，最小面积矩形。**新知识：对角映射。**首先用 `unordered_map<int, set<int> >` 结构插入 x 与 y 的映射关系。而后再次遍历，如果`m[x1].count(y2) && m[x2].count(y1)`，这里注意 x 和 y 的关系，就说明`x1y1, x1y2, x2y1, x2y2` 能组成矩形。