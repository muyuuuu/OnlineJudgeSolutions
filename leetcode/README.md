# 题解整理

注：这里的题解会很粗糙。一些约定：
- TO，timeout，表示超时
- WA，wrong answer，表示错误

## 哈希

1. 第 1 题，寻找目标序列中两数之和等于目标值。暴力可以通过，但不好。使用哈希，空间换时间。第一次遍历数组，标记每个数的位置。第二次遍历数组，看看那个数在不在。
2. 第 3 题，寻找最长的子序列。哈希 + 滑动窗口。利用 map，标记一个字符是否出现过。使用滑动窗口 start 和 end，end 向后移动。遇到重复，更新 start；不重复，标记当前符号的位置。最后结果是 end - start + 1。
3. 第 136 题，查找序列中只出现一次的数。通解，使用哈希。适用于此题的解，因为其它数据都出现了不多不少整整两次，所以可以使用异或运算。因为 `b ⊕ a ⊕ a = b, a ⊕ a = 0`，所以只需在线性的空间内完成。
4. 第 347 题，寻找最大的 K 个数。使用 map 记录元素出现次数。将值和次数放入 vector，对值排序。而后输出前 K 个值的 idx。
5. 第 187 题，寻找出现多次的子序列。使用 map 能解决。但需要注意的是，滑动窗口的长度能取等号，子串取法，以及 if else 的顺序和标记一个字串出现过第二次。
6. 第 447 题，回旋标的数量。两次遍历，记录于当前点的距离，而后结果是 `res * (res-1)`。不要求排序，所以建议使用 unordered_map，而不是 map。
7. 第 451 题，给定一个字符串，请将字符串里的字符按照出现的频率降序排列。`tree -> eert`，首先无序 map 记录每个元素出现的次数。构建一个结构体，将元素、元素出现的次数放入一个向量中，对向量排序。然后输出。此题可以理解固定模板。
8. 第 554 题，砖墙。应该使用 map 记录每个缝隙出现的次数，而不是使用数组，因为数组会内存爆炸，且要逐个遍历。
9. 第 981 题，基于时间的键值存储。创建二级哈希表，key->timestamp->value，查找的时候先找 key，没有返回空。如果有，timestamp->value 使用有序 map，upper_bound 方法查找即可。没有找到的情况是：`m.upper_bound(key) == m.begin()`，返回空；如果找到，返回上一个元素的 second。
10. 第 939 题，最小面积矩形。**新知识：对角映射。** 首先用 `unordered_map<int, set<int> >` 结构插入 x 与 y 的映射关系。而后再次遍历，如果`m[x1].count(y2) && m[x2].count(y1)`，这里注意 x 和 y 的关系，就说明`x1y1, x1y2, x2y1, x2y2` 能组成矩形。
11. 第 895 题，最大频率栈。空间换时间。一个 map 记录元素出现的次数，一个 map 记录出现次数对应哪些元素。弹栈时，先按频率弹，弹空了，频率自减。频率相同，按元素到来顺序弹出，所以第二个 map 的 value 用 stack 实现。
12. 第 1726 题，稀疏相似度。我感觉我的思路清晰代码简单，可为什么错了呢？答案的代码都很复杂，懒得看，一定是测评机的问题。不过学到了保留4位小数的做法。
13. 第 1002 题，变位词组。字典不能被哈希，使用map时需要注意。每个单词错位了，所以可以排序来得到一个标准，对排序后的单词进行哈希。注意不能映射为0，因为没有映射也是0。二维vector操作时，需要先分配空间，后期在删除多余的。
14. 第 1624 题，数对和。另辟蹊径的思路，标记需要哪个数。如果这个数出现了，就说明可以配对了。要求一个数只能在一个数对中，所以，配对后 map 的值要自减。
15. 剑指offer48题，最长不含重复字符的子字符串。和第三题一样，这里需要注意的是，移动起点指针。每次都要计算结果和移动尾部指针。
16. 第 1488 题，避免洪水泛滥。难点是，当前天数是晴天，如何确定抽取哪一个湖。换个角度，晴天不抽任何湖，遇到雨天且这个湖满了，看看这一天之前有没有晴天，有的话，就抽了，没有的话，只能洪水了。思路值得借鉴。
17. 第 1072 题，按列翻转得到最大值等行数。又是借助异或的运算。并不是真的要去反转，而是看有多少类似的字符串。取出同类型字符串最大的数，就是结果。如果行以0开头，则将行中所有数取反，如果是1开头，保持不变；然后看有多少个相同的字符串，选择其中个数最大的。
18. 第 1814 题，统计一个数组中好对子的数目。nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])，统计自己和自己反差相等的数量，最后等差数列那个求和就行。
19. 第 1679 题，和 1624 题思路类似，目标是 5，当前值是 1，则 m[4] ++。

## 栈的应用

20. 第 739 题，每日温度。暴力破解会超时，单调栈的应用，如果栈不为空且当前元素大于栈顶元素，弹栈，栈顶元素对应的索引计算天数。否则，压如当前温度的索引。
11. 第 895 题，最大频率栈。空间换时间。一个 map 记录元素出现的次数，一个 map 记录出现次数对应哪些元素。弹栈时，先按频率弹，弹空了，频率自减。频率相同，按元素到来顺序弹出，所以第二个 map 的 value 用 stack 实现。
21. 第 1190 题，**华为机试原题**，反转每对括号间的子串。遇到左括号，说明左括号前面的内容保留不动，压入之前的内容，单词清空；遇到右括号，说明和左括号之间的内容要反转，反转单词，和之前保留不动的内容相加；否则，做默认的字符相加。