### 226 题，

反转二叉树，使用递归思路进行求解。

- 首先要判断递归退出情况，就是当前节点为空的时候，返回空指针。
- 而后对当前树的孩子节点进行反转；
- 最后递归调用当前孩子节点的左孩子和右孩子即可。

函数由 root 进入调用，返回时仍然要返回 root。

### 116 题，二叉树连接兄弟节点

同上面这道题，还是使用递归思路求解。

- 递归退出的情况，就是节点为空的时候，此时返回空;
- 而后是递归左右两个孩子的连接，`t1.left=t2.right`；
- 同时不要忘记连接不同树之间的孩子，也是递归完成；

退出时，仍然要返回 `root` 节点。

### 114 题，二叉树展开为链表

这道题的递归重点是元素的移动。

1. 退出递归的情况，节点为空指针，直接退出
2. 而后是抻平子树，并将右子树孤立出去
3. 访问抻平的子树，将子树最后一个节点指向孤立的有子树。这也是这道题目的重点，而不是直接将子树的左孩子指向右孩子。

### 654 题，构建最大二叉树

这道题同样是递归中的经典。

1. 首先分析题目，发现创建树需要传入数组和最大值索引，以此确认左右边界，左边界内是左子树，右边界内是右子树；
2. 如果左边界大于右边界，说明越界，返回空指针；
3. 而后访问当前区域内的最大值和索引，索引左侧构建为节点的左子树，索引右侧构建为节点的右子树。
4. 最后返回根节点。

这里有些地方可以优化，比如这次建树的区间是 `[1, 3]`，不用对向量进行截取，直接传入 `[1,3]`，访问这一区间内的数据即可。

### 105 题，前序中序建立二叉树

根据前序和中序遍历的特点，我们知道前序的第一个节点就是根节点，而中序遍历对应的根节点的左侧都是根节点的左子树，右侧都是右子树。以此为依据建立二叉树，使用序列的索引为依据，构建二叉树：

1. 按照前序遍历查找到根节点，遍历中序，找到根节点对应的索引，减去根节点的索引，就知道左子树的数量，同理，可以知道右子树的数量。
2. 按照根节点的数值，创建树节点
3. 而后开始递归建立二叉树，注意传入序列的索引。

看代码吧，这里不好描述。

### 106 题，后序中序建立二叉树

这道题和上面的题一样，同要是需要找到每次建立树的区间。需要注意的是，可以在草稿纸上画一个不对衬的树，以此计算每次选择的区间。
