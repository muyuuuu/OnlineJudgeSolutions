### 226 题，

反转二叉树，使用递归思路进行求解。

- 首先要判断递归退出情况，就是当前节点为空的时候，返回空指针。
- 而后对当前树的孩子节点进行反转；
- 最后递归调用当前孩子节点的左孩子和右孩子即可。

函数由 root 进入调用，返回时仍然要返回 root。

### 116 题，二叉树连接兄弟节点

同上面这道题，还是使用递归思路求解。

- 递归退出的情况，就是节点为空的时候，此时返回空;
- 而后是递归左右两个孩子的连接，`t1.left=t2.right`；
- 同时不要忘记连接不同树之间的孩子，也是递归完成；

退出时，仍然要返回 `root` 节点。

### 114 题，二叉树展开为链表

这道题的递归重点是元素的移动。

1. 退出递归的情况，节点为空指针，直接退出
2. 而后是抻平子树，并将右子树孤立出去
3. 访问抻平的子树，将子树最后一个节点指向孤立的有子树。这也是这道题目的重点，而不是直接将子树的左孩子指向右孩子。

### 654 题，构建最大二叉树

这道题同样是递归中的经典。

1. 首先分析题目，发现创建树需要传入数组和最大值索引，以此确认左右边界，左边界内是左子树，右边界内是右子树；
2. 如果左边界大于右边界，说明越界，返回空指针；
3. 而后访问当前区域内的最大值和索引，索引左侧构建为节点的左子树，索引右侧构建为节点的右子树。
4. 最后返回根节点。

这里有些地方可以优化，比如这次建树的区间是 `[1, 3]`，不用对向量进行截取，直接传入 `[1,3]`，访问这一区间内的数据即可。

### 105 题，前序中序建立二叉树

根据前序和中序遍历的特点，我们知道前序的第一个节点就是根节点，而中序遍历对应的根节点的左侧都是根节点的左子树，右侧都是右子树。以此为依据建立二叉树，使用序列的索引为依据，构建二叉树：

1. 按照前序遍历查找到根节点，遍历中序，找到根节点对应的索引，减去根节点的索引，就知道左子树的数量，同理，可以知道右子树的数量。
2. 按照根节点的数值，创建树节点
3. 而后开始递归建立二叉树，注意传入序列的索引。

看代码吧，这里不好描述。

### 106 题，后序中序建立二叉树

这道题和上面的题一样，同要是需要找到每次建立树的区间。需要注意的是，可以在草稿纸上画一个不对衬的树，以此计算每次选择的区间。

### 652 题，寻找重复的子树

显而易见，判断某个序列是否重复出现，应该考虑使用 `map` 这样的数据结构。而且，`unordered_map` 的 key 不能为序列。

1. 首先，从根节点开始遍历二叉树，建立根节点的子序列；
2. 从某一个节点开始，使用深度优先算法建立子序列，将序列结果返回，这需要一个 `dfs` 函数，如果当前节点为空，追加负数体现树的结构；
3. 而后递归建立根节点孩子的序列，这需要一个 `build` 函数，如果当前节点为空，不用构建，返回。

将序列存入 `map`，最后看哪个 `map` 的结果超过了 2 即可。这里有一个细节需要注意，如果当前节点为空，需要对空节点赋值，如 -10, 否则向左的斜二叉树会和向右的斜二叉树相同。

### 230 题，二叉搜索树的第 k 小元素

这个相当于二叉搜索树入门的题目。因为二叉树的左节点小于根和右节点。

所以，在遍历的时候，先遍历左子树直到节点为空，而后添加数值，而后遍历右子树。最后返回第 k 个元素即可。

### 538 题，BST 转累加树

累加树：使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。也就是说，原二叉树中，右子树的值一定大于左子树的值，所以从右子树开始遍历，依次求累加和。

遍历到不能遍历的时候，更新累积和即可。而后遍历左子树。

### 700 题，BST 中的搜索

BST 的查都可以概括为：如果找不到，返回空指针；如果找到了，就做点什么；如果比目标小，就去右子树找；如果比目标大，就去左子树找。

### 98 题，BST 中的验证

验证一棵树是否为 BST 树，常规思路是将二叉树的中序遍历结果存储到一个容器中，判断容器是否为升序即可。所以可以使用中序遍历来求解这个问题。

- 如果节点为空，那么说明没有查找到问题，返回 true
- 而后开始递归检查左子树，直到最左侧的左子树
- 如果左子树没问题，那么就设置变量的值为最左侧左子树的值
- 之后判断其他节点的值是否小于变量的值，如果小于，说明不是 BST
- 而后递归检查右子树即可

### 701 题，BST 插入

BST 的插入建议用递归实现，而递归函数的设计也有技巧。

- 如果递归函数没有返回值，那么插入时需要判断和父节点的大小，且被插入的 BST 是否为空；
- 如果递归函数有返回值，那么将不用判断和父节点的大小，也不用判断树是否为空。

### 450 题，BST 的删除

同上一题，递归函数要有返回值，别忘了。在删除的许后需要注意：

- 如果子节点有空的，返回另一个子节点
- 如果子节点都不为空。那么当前节点的替换值为右子树中最小的元素，寻找此元素，将节点的值替换。而后删除右子树最小的元素即可。也就是说不用真的移动节点，进行替换即可。

### 96 题，有多少 BST

给定一个数值 n，求 [1, n] 内的数字可以组成多少 BST。这道题的思路比较经典，使用递归来做。

首先，我们以 i 为根节点，那么此时能组成的 BST 就是左子树的数量乘以右子树的数量。也就是，一个大问题可以划分为多个小问题。那么只要从 1 到 n，另每个节点都作为根节点即可。

而递归的退出条件是，当区间的左侧大于右侧时。为了防止超时，可以把中间结果记录下来，如果某个结果已经计算，那么直接 return。

### 有多少 BST, 并构造

其实这道题和上面这个题目类似，要有整体的观念。

上面是获取左子树的数量和右子树的数量，这里就是获取左子树的集合和右子树的集合。上面是数量相乘就得到了总数，那么这里是遍历两个容器，就得到了所有 BST 树。

即每次循环时，都要重新创建根节点，然后设置根节点的左右子树即可。

### 1373 题，二叉搜索树中的最大 BST

代码写到这里，也稍微领悟了树的算法。无非是：如何遍历，遍历到节点后做些什么，而我们可以无条件相信递归，换句话说，我们拿到递归后的东西，该做些什么。

这道题使用的是后序遍历，那么什么时候使用后序遍历呢？答案就是需要使用左右节点计算根节点时，使用后序遍历。因为要判断以某个节点为根节点时，这个子树是否为 BST，且需要记录这个子树的和，最大值、最小值（子树扩大时和新加入的节点比较）。既然每个节点都需要记录这样的信息，那么给每个节点都设立一个 4 维的数组，表示：是否为 BST，子树最小值，子树最大值，子树的和。

在拿到递归结果后（我们无条件相信递归），创建这个节点的数组，并使用左右子树的结果来更新当前节点的数组即可，若当前节点是 BST,那么更新最大值。

### 297 题，二叉树的序列化与反序列化

序列化：无非是先序、中序、后序这三种方式遍历二叉树，并添加数值到字符串中即可。这里需要注意的是，记得添加分隔符，不然 123 可以表示 12 和 3 也可以表示 1 和 23。

反序列化，将字符串按空格分割读取，存入到 vector 中，读取 vector 建立二叉树即可。如果序列化用的先序，那么反序列化就也要用先序去建立二叉树。建立根，建立左，建立右这样的顺序即可，遇到空则返回空指针。如果记得每建立一个节点，索引就自增，包括空节点。
