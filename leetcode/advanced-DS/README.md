### 146 题，实现 LRU

关于这个的实现，我发现还是挺有意思的。做到了：逻辑结构分离、业务低耦合和高内聚，多个模块配合实现任务。在之后的时间里，我会继续完善这个东西。包括：

1. 怎么定义满了？按照 key 的数量？还是按照整个 cache 保存的内容的 memory size？分别怎么实现？
2. 现在只有一种淘汰方式：缓存满了淘汰。但是如果我想给每个 node 加一个超时怎么办？超时 or 缓存满了就淘汰。这个要怎么设计？怎么实现？

### 460 题，实现 LFU

不能使用优先级队列，因为无法删除中间节点。而这个题的核心点还是节点的设计，LRU 可以使用哈希链表，而这个题需要使用二叉树（集合）。

1. 首先节点应包括：key-value，cnt 和 time；其次包括重载的 < ，用于快速删除
2. 对于 get，需要把节点在集合中删除，而后更新节点的访问次数和时间，在插入集合
3. 对于 put，如果在缓存中，那么和 get 类似，更新节点的状态；如果不在缓存中，就需要插入。插入前先看看是否溢出，如果大小溢出，删除集合中最小的元素，根据集合最小的 key 删除哈希表中的元素；删除之后，插入新的节点。

不能是插入后在删除，因为很可能把新插入的节点给删掉。所以要先删除，在插入。
