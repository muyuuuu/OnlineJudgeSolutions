### 46 题，全排列

概括一下搜索的核心要素：

1. 判断是否满足条件，退出
2. 不满足条件，如何选择下一条路径
3. 选择路径后，回溯，也就是撤销选择

这道题额外需要的判断就是，判断当前元素是否被添加，使用 map 就好了。

### 77 题，组合

返回范围 [1, n] 中所有可能的 k 个数的组合。

我们思考下这个题，与全排列不同的是，题目的含义是不全选，也就是说，有的要选择，有的可以不选，且不能重复。那么在回溯的时候，就不能遍历枚举了，因为这样会有重复的结果。在进入回溯之前设置遍历，回溯中调用回溯的时候变量自增可以避免重复。既然有的元素不选，那么分两种情况：

1. 添加元素，调用回溯
2. 不添加元素，调用回溯

这样，不添加元素时，就进行了元素的删除，且每次调用回溯时都是通过变量的自增实现，也避免了重复。判断时，因为要求满足 k 个元素，所以只能判断临时数组的长度是否为 k。

### 78 题，子集

与全排列不同的是，题目的含义仍然是不全选，那么回溯时就需要：添加元素，调用回溯，删除元素，再次调用回溯。由于子集的长度不是固定的，我们重新来思考这个不选择的问题，不选择也是一种选择，那么我们可以：选择的次数达到要求时返回即可，因此判断条件为选择次数等于 nums 的长度，因为有的没有做选择，那么最终的子集呈现的结果就是长短不一。

### 22 题，括号生成

生成 n 对合法的括号，回溯的时候判断一对括号是否合法，过滤掉不合法的情况后，判断合法并压入结果。在回溯阶段，分别压入左括号，回溯并返回，压入右括号回溯并返回即可。

### 797 题，所有可能的路径

这是我做图题目的第一题，还是那句话，不要陷入递归的细节。不过这道题不同的是，使用了一个结果存储了所有可能结果，不像之前的树那样，对每一个节点创建结果。

首先从 0 开始遍历：

- base case：因为这是无环图，遍历到最后一个节点，就说明找完了，添加结果
- 否则，访问 0 节点指向哪个节点，然后添加这个节点，在递归调用遍历节点的函数
- 在一条路径查找完毕后，应该 pop\_back, 如第一次查找的路径是 0 1 2 3，那么回溯的时候就是 0 1 2 这样去查找。

### 207 题，有向图环检测

个人建议使用深度优先遍历来解决问题。首先使用二维 vector 来初始化数组，创建 visited 来存储一个节点是否被访问过，0 表示没有被访问，1 表示被访问过，2 表示这个节点所在的任何边都没问题。

注意，遍历前判断：当前节点是否没有被访问，如果被访问过，就不访问了。访问期间节点的值为1，表示节点被访问，可能还会被访问；访问结束后，节点的值为 2，表示这个节点所在的边没问题，不存在有向环。

如 A 节点被访问过，那么遍历时的入口节点就忽略 A；如果从 B 开始遍历，发现 A 被访问过了且取值不为 2，就说明这里是有环的图。

### 210 题，可能的路径

这个比第一题简单些，只用求一条路径。此类拓朴排序的题目我建议使用 dfs 算法：

1. visited 数组有三个取值，0 表示可以遍历，1表示正在遍历，2 表示遍历完成。需要理解的是，并非遍历过就不能在遍历了。
2. 重点就是，在遍历完后，做一些什么。如果是求全部路径，那么就需要回退和判断是否遍历完成，如果是求单个可行路径，那么就不用。

### 51 题，N 皇后

典型的回溯题目，如果按行放置：

1. 行达到 N 时，表明放置完毕，返回结果
2. 否则遍历列，判断当前列是否满足放置条件，不满足，下一个；满足，放置，遍历下一层，回溯
3. 因为是按行放置的，因此，判断满足只需要判断：列、左上、右上这三种情况

### 698 题，划分 k 个相同的数组

这个是比较经典的回溯算法了，这里准备写详细一些。以数组为视角，无非是将数组元素放入不同的桶，那么判断条件为：

1. 判断能否放入时，只需要判断是否大于平均值即可
2. 所有元素都放入后，只需要判断所有桶的元素是否等于平均值，即可判断是否合法

因为这个体要求返回是否能放入，并不要求返回放入的结果，因此在判断合法性、递归调用上要加入返回语句，且回溯的最好也要加上返回的语句。

N 皇后以行为视角时，放入列要暴力枚举，这个题也一样，以数组为视角，放入元素时就要暴力枚举桶，查看是否能放入。

### 37 题，解数独

这个题也应该是回溯算法中比较经典的例子了，与 N 皇后不同的是，N 皇后只有一类棋子，数独有 9 类，因此，N 皇后的遍历是以列为视角，数独的遍历是以 9 个变量为视角。在回溯期间自增行和列。

回溯可以设置返回 bool 值，当找到一个解就立刻返回，加快程序的查找速度。在这里有一些注意事项：

```cpp
if (col == 9) {
    return dfs(board, row + 1, 0);

if (row == 9) {
    return true;

if (board[row][col] != '.') {
    return dfs(board, row, col + 1);
}
for (char ch = '1'; ch <= '9'; ch++) {
    if (!valid(board, ch, row, col)) {
        continue;
    }
    else {
        board[row][col] = ch;
        if(dfs(board, row, col + 1)) return true;
        board[row][col] = '.';
    }
}
```

什么时候用 if 返回，什么时候不用呢？答案是只在搜索的时候用 if，此时表示找到解了，返回，如果没有找到解，也就是 false，不返回，继续找，如果这里返回 false，最终呈现的结果就是还没有找完。而其他情况，没找到就是没找到，返回没找到即可。

### 111 题，二叉树的最小高度

bfs 找到的路径一定是最短的，但空间复杂度高，一般用于求解一副图中 start 节点到 target 节点的最短距离。在求二叉树的最短路径中，使用 bfs，每次遍历一层节点，并判断是否满足叶子节点，不满足的话高度自增。使用的数据结构是双端队列，位于头文件 `deque` 中。

### 752 题，打开转盘锁

同样是在图中求最短路径，所以使用 bfs。不过需要增加额外的限制：

1. 防止遍历已经遍历过的节点，往队列中添加元素时需要判断是否被访问过，如果没有，添加，并设置已经访问。
2. 可以添加死亡节点，添加进去不会有坏处，只需要什么都不做就可以了。不能在添加的时候判断是否为死亡节点，因为这样默认了操作的节点是允许的节点，但一种可能情况是，初始节点就是死亡节点，这个时候已经操作死亡节点，是不允许的。所以要在 bfs 的外面判断。
