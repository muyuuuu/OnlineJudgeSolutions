### 第 380 题，O(1) 时间插入和删除元素

这个题的核心就是如何巧妙的设计数据结构，既然 O(1) 的时间，必然要使用哈希；而插入、删除和访问元素，链表与哈希表不能实现，因此考虑不定长数组来实现。

### 第 710 题，避免黑名单中的随机数

尝试用 380 题目的思路去删除黑名单中的元素，结果超时。后来发现用的是哈希。将黑名单中的数值映射到白名单即可，有以下注意事项：

1. 判断映射的值是否在黑名单
2. 如果黑名单的值超过可取值的范围，不用映射，否则会出现值不够取而出现负数
3. 最后 pick 时，选择可取值的范围，这样就忽略了上面没映射的值

### 870 题，田忌赛马

首先将两人的马降序排列，如果比的过，就不用保存实力；如果比不过，用最小的值来当炮灰。

### 第 26 题，原地删除数组重复元素

由于这个题最后返回的是数组索引，所以可以不用真的删除。技巧为双指针，如果相等，快指针向后移动，如果不等，慢指针向后移动并赋值，最后返回慢指针的索引。

### 第 83 题，原地删除链表中的重复元素

和 26 题一样，不过需要注意的是，断掉 slow 和后面元素的连接。

### 第 27 题，移除元素

和双指针删除数组元素一样，如果和要移除的元素不等，操作双指针，如果相等，快指针向后移动。

### 第 283 题，移除数组中的 0

和 27 题一样，最后移动 slow 指针，把所经之处设为 0 即可。

### 第 560 题，和为 K 的子数组

前缀和主要用来处理数组分组的问题，频繁查询数组的区间和，此外还可以进行进一步优化，使用哈希避免不必要的循环。前缀和数组注意事项：

1. 前缀和比原数组多一项，且第一项为 0
2. 求和为 k 的子数组，就是某个数组减去某个数组的差值为 k，直接用前缀和相减即可，但二重循环会超时。

因此需要使用哈希记录前缀和出现的次数，如果需要的前缀和已经出现了，直接得到结果，避免二重循环。

### 1109 题，航班预定统计

差分数组的主要目的是频繁对某个区间的数组元素进行增减。差分数组和原数组同等大小，差分数组是后一项减前一项得来。

差分数组可以快速对数组进行增减操作，对 `nums[i...j]` 元素全部 +3，只需要 diff[i]+3, diff[j+1]-3，即可注意不要越界。

### 5 题，最长回文子串

这个题是粗暴的遍历，遍历到一个字符时，判断当前最长的回文子串，然后保留下历史最长的回文子串。回文子串可能是奇数，可能是偶数。如果是奇数，那么两个指针相等，如果是偶数，那么右边的指针比左边的指针大一位。

然后移动指针，确定当前的回文子串即可。
