### 191 题，位 1 的个数

`n&(n-1)` 会去除 n 最后的一位 1。循环去除即可。

### 231 题，2 的幂

2的幂的二进制只有一个 1, 所以判断 `n&(n-1)` 是否等于 0 即可。

### 172 题，阶乘末尾 0 的个数

这个题主要是计数 5 的倍数的个数，因为只有 5 会导致末尾是 0，没有偶数？不可能的，只要出现 5，就一定有 2，只要出现 10，就一定有 6。所以计数 5 的倍数的个数即可。此外，还有 25 这样的特殊数字，他是 5 的 5 倍数，也就是说，能提供两个 5，同理，50, 75, 100 都能提两个 5，125 则能提供 3 个 5。

所以写一个循环，设置变量是 5 的 5 倍数，统计能提供几个 5，几个 25，几个 125，直到这个倍数大于 n 退出循环。

### 793 题，阶乘末尾有 K 个零的共有几个数

这个题直接二分搜索左右边界会超时，需要使用一些技巧。如果一个数的阶乘末尾有 K 个 0，那么相邻的 5 个数末尾有 K 个 0，查找到结果后直接返回 5，否则就是 0。`5x-1 < 5x = 5x + 1 = 5x + 2 = 5x + 3 = 5x + 4 < 5x + 5`。

### 204 题，高效寻找素数

设置备忘录，把查找过的数值都记录为不是素数即可。创建数组初始化为 true，由于素数的起点是 2，从 2 到 n 开始遍历，对于每个数的 2,..,i 倍都设置为不是素数即 false。最后遍历数组，统计 true 的数量即可。

### 372 题，超级次方

计算 x^b % 1337 的答案，b 是一个很大很大的数。这个题有两点：

- a^{1234} = a^4 \* a^{1230}，如此递归即可，当 b 为空时，返回 1
- (a\*b)%k = (a%k)(b%k)%k，这样，在计算 a^b 的时候即可以节省计算量，每次乘法结束后都 % 一下即可

### 448 题，找到数组所有缺失元素

如果是在时间 O(n) 以内，那么我还是建议额外开辟一个数组直接统计方便一些。

如果要求空间复杂度，那么将原数组视为哈希数组就可以了，将数组元素 (x - 1) % n 后视为索引，这样索引不会越界，将索引元素 + n，最后遍历数组，查看哪个数组数值小于 n 即可，因为从数值构建索引的过程 - 1 了，所以缺失数值就是索引 + 1。

### 645 题，寻找缺失和重复元素

因为这个题限制而缺失和重复的只有 1 个元素，也就是说，重复一个，对应的也会缺失一个。所以还是将原数组视为哈希表：

1. 元素对应索引，为防止越界，索引需要 -1。索引的数值乘以 -1，如果数值已经小于 0，说明元素重复
2. 遍历数组，如果数组元素大于 0，说明元素缺失，其索引 + 1 为缺失值

### 382 题，链表节点随机选择

如何不在遍历数组预知数组长度的情况下随机选择一个元素，答案是：对于第 i 个元素，选择的概率是 `1/i`，这样，选择第 `i` 个元素的概率就是 `1/n`。

在随机选择的时候，每次都要重新遍历链表。

### 398 题，随机数索引

与 382 题不同的是，这个要随机选择一个数，并返回这个数可能的索引。所以需要加一个额外的判断，那就是：只有当前数值等于 target 时，才进行随机选择，有 1/i 的概率选择当前元素。

### 292 题，Nim 游戏

如果要拿到最后一块石头，那么当石头是 4 的倍数时，无论如何都是要输，而不是 4 的倍数时，就会赢。或者说，谁面临的石头数是 4 的倍数，就会输。

### 877 题，石头游戏

这个题可以重新思考：由于只能拿到最左和最右的石头，那么，石头可以分为奇数组和偶数组，只要选择一组最大的就能赢，最多也是平局，因此不存在输的可能。

### 319 题，灯泡开关

一种思路是直接模拟然后输出答案，一种思路是找规律，随便列举一个数字，那么它只会在遇到它的因子时状态发生改变，那么就看看谁的因子数量是奇数个，只有平方的时候状态保持为开，所以求根号就可以了。
