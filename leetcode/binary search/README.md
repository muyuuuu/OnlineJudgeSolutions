- 第 35 题，搜索插入位置。最朴素的二分法，如果元素在，返回索引，如果不在，返回应该插入位置的索引。注意循环条件与退出条件。
- 第 349 题，两个数组的交集。首先对两个数组进行排序，而后两个索引分别遍历数组。比较第一个数组与第二个数组的大小。如果相等，判断不重复后追加；无论是否相等，索引都要自增；如果小于，第一个数组的索引自增，如果大于，第二个数组的索引自增。
- 第 350 题，两个数组的交集 II。和 349 题类似，不过加了限制，一个元素可以出现多次，但出现次数应与元素在两个数组中出现次数的最小值一致。第一种方案，哈希，记录第一个数组中每个元素出现的次数，如果第二个数组中出现了，追加，次数--，当次数为 0 时，说明是出现次数的最小值。第二种方案，排序后双指针，不过不用判断这个元素是否出现过了。
- 第 374 题，猜数字大小。最简单的二分应用，注意如何使用题目提供的接口。
- 第 441 题，排列硬币。因本人追求的是常规思路，所以暴力破解了。其实二分也行，需要借助等差数列的求和公式。
- 第 392 题，判断子序列。可以将时间复杂度从 `NM` 降低到 `N+M`，只需一次遍历。如果匹配上了，子串自增，而无论如何，被查找的字符串一定自增，最后查看子串的索引是否等于长度即可。
- 剑指 offer 53 题，在排序数组中查找数字 I。两种方案，第一种方案是 lower_bound 和 upper_bound，包含在头文件 algorithm 中。第二种方案是二分，不过需要增加额外的判断条件。除了保留最原始的 mid 判断外，还要增加左侧边界的判断。在左侧是目标的条件下，如果右侧是目标，返回；如果中间是目标，右侧递减；如果都并不是，右侧等于 mid - 1。当然，也可以通过右侧是目标的条件进行判断。
- 剑指 offer 1005 题，稀疏数组搜索。本质是二分，不过需要增加额外的空字符串删除。如果中间是空，中间指针向右移动，**注意越界判断，**如果 mid >= right，说明 mid 到 right 都是空，r -= 1 直接下一循环；如果不是，进行常规的二分判断。