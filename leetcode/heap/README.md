1. 第 1046 题，最后一块石头的重量。不用真的建立堆，可以使用优先级队列。`priority_queue<int> q` 大顶堆；`priority_queue<int， vector<int>, greater<int> > q` 小顶堆。
2. 第 703 题，数据流中的第 K 大元素。不能使用向量，每次都排序，会超时。用优先级队列，限制队列长度为 `K` 。每次访问元素时，直接返回堆顶元素。
3. 剑指 offer 40 题，最小的k个数。方案 1 排序；方案 2，因为保留最小的数，所以用大顶堆，把数据大的弹出去。
4. 剑指 offer 41 题，数据流中的中位数。排序肯定超时。用两个堆，第一个大堆顶，存储有序数据的前部分；第二个小堆顶，存储有序数据的后部分。在添加数据时实现有序。如果两个堆的数量相等，现在小堆中添加，而后小堆弹出，放到大堆；如果不相登，大堆添加，而后弹出，弹出的内容放到小堆。
5. 剑指 offer 17.20 题，连续中值。和剑指 offer 41 题相同。
6. 第 692 题，前K个高频单词。老本行，多目标的结构体排序。
7. 第 1845 题，座位预约管理系统。优先级队列，小堆顶。
8. 第 0502 题，IPO。我也不知道为啥常用的结构体多条件排序失效了。双堆，第一个堆按照成本顺序排序压入，第二个堆选择第一个堆中低于成本的最大利益，依次相加。
9. 第 1753 题，移除石子的最大得分。最大堆的应用，每次选择最大的两个弹出，再压入最大值减一的数值，知道队列元素出现两个0。