1. 第 1046 题，最后一块石头的重量。不用真的建立堆，可以使用优先级队列。`priority_queue<int> q` 大顶堆；`priority_queue<int， vector<int>, greater<int> > q` 小顶堆。
2. 第 703 题，数据流中的第 K 大元素。不能使用向量，每次都排序，会超时。用优先级队列，限制队列长度为 `K` 。每次访问元素时，直接返回堆顶元素。
3. 剑指 offer 40 题，最小的k个数。方案 1 排序；方案 2，因为保留最小的数，所以用大顶堆，把数据大的弹出去。
4. 剑指 offer 41 题，数据流中的中位数。排序肯定超时。用两个堆，第一个大堆顶，存储有序数据的前部分；第二个小堆顶，存储有序数据的后部分。在添加数据时实现有序。如果两个堆的数量相等，现在小堆中添加，而后小堆弹出，放到大堆；如果不相登，大堆添加，而后弹出，弹出的内容放到小堆。
5. 剑指 offer 17.20 题，连续中值。和剑指 offer 41 题相同。
6. 第 692 题，前K个高频单词。老本行，多目标的结构体排序。
7. 第 1845 题，座位预约管理系统。优先级队列，小堆顶。
8. 第 0502 题，IPO。我也不知道为啥常用的结构体多条件排序失效了。双堆，第一个堆按照成本顺序排序压入，第二个堆选择第一个堆中低于成本的最大利益，依次相加。压入堆时，注意默认的排序，不要想当然。`q.emplace(capital[i], profits[i])` 和 `q.emplace(profits[i], capital[i])` 带来的结果是不同的。
9. 第 1753 题，移除石子的最大得分。最大堆的应用，每次选择最大的两个弹出，再压入最大值减一的数值，知道队列元素出现两个0。
10. 第 973 题，最接近原点的 K 个点。大堆顶的应用，学会使用 `emplace`，以及自定义优先级队列中元素如何[排序](https://www.cnblogs.com/huashanqingzhu/p/11040390.html)。对于 `pair` 类型的数据，先比较第一个，如果相等在比较第二个。
11. 第 767 题，重构字符串。其实是哈希的应用，先记录每个单词出现的频率。如果最大频率超过了长度的一半，无法重构。而后，按照每个单词出现的次数，分散排列开，先插入到奇数，而后插入偶数，保证相邻单词不同。
12. 第 719 题，找出第 k 小的距离对。用堆超时，但看不懂其它答案。学完二分在回来看吧。
13. 第 215 题，数组中的第K个最大元素。送分题。
14. 第 23 题，合并K个升序链表。使用优先级队列，先压入每个队列的第一个元素。而后当队列非空，依次弹出队列最小的元素。假设这个元素来自第二个链表，就压入第二个链表的下一个元素。以此类推。
15. 第 857 题，雇佣 K 名工人的最低成本。堆的应用，先创建`pair<单价，质量>`，按单价排序。之后创建队列，压入之前按单价排序的数组。当满足数量时，用最后压入的单价乘以累积的数量，保证给所有人开出高于期望的工资。如果实在看不懂，就画图了解下。
16. 第 1705 题，吃苹果的最大数目。这里需要注意的是，删除过期苹果的天数用等号，追加苹果数量时，要判断是否还在天数限制内。优先级队列或者哈希都可以。
17. 第 1792 题，最大平均通过率。优先级队列，优先级是：增加一个成员后，谁的通过率提高的最多，所以用大堆顶。
18. 第 1054 题，距离相等的条形码。和第 767 题目思路一样。先用 map 统计元素次数，而后初始化到 vector 中。对 vector 按照频率出现次数的逆序排列，间隔插入结果中。
19. 第 1834 题，单线程 CPU。和 502 题思想类似。首先，创立每个任务的索引，并按照到达时间进行排序。而后，创建时间戳和小顶堆，堆按照任务的处理时间进行排序。如果队列为空，根据按照时间排序的 vecotr 更新时间戳，然后在小于该时间戳内，添加任务到优先级队列中。因为任务已经排序好了，所以，直接取出队首元素，记录任务号，并更新时间戳。
20. 第 1439 题，有序矩阵中的第 k 个最小数组和。每个数组中都必须被抽出元素，所以可以暴力破解。`pre` 是之前的数组，`cur` 是当前数组，每个元素都相加，排序，筛选前 k 个。