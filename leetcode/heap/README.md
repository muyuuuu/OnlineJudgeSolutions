1. 第 1046 题，最后一块石头的重量。不用真的建立堆，可以使用优先级队列。`priority_queue<int> q` 大顶堆；`priority_queue<int， vector<int>, greater<int> > q` 小顶堆。
2. 第 703 题，数据流中的第 K 大元素。不能使用向量，每次都排序，会超时。用优先级队列，限制队列长度为 `K` 。每次访问元素时，直接返回堆顶元素。
3. 剑指 offer 40 题，最小的k个数。方案 1 排序；方案 2，因为保留最小的数，所以用大顶堆，把数据大的弹出去。
4. 剑指 offer 41 题，数据流中的中位数。排序肯定超时。用两个堆，第一个大堆顶，存储有序数据的前部分；第二个小堆顶，存储有序数据的后部分。在添加数据时实现有序。如果两个堆的数量相等，现在小堆中添加，而后小堆弹出，放到大堆；如果不相登，大堆添加，而后弹出，弹出的内容放到小堆。
5. 剑指 offer 17.20 题，连续中值。和剑指 offer 41 题相同。
6. 第 692 题，前K个高频单词。老本行，多目标的结构体排序。
7. 第 1845 题，座位预约管理系统。优先级队列，小堆顶。
8. 第 0502 题，IPO。我也不知道为啥常用的结构体多条件排序失效了。双堆，第一个堆按照成本顺序排序压入，第二个堆选择第一个堆中低于成本的最大利益，依次相加。
9. 第 1753 题，移除石子的最大得分。最大堆的应用，每次选择最大的两个弹出，再压入最大值减一的数值，知道队列元素出现两个0。
10. 第 973 题，最接近原点的 K 个点。大堆顶的应用，学会使用 `emplace`，以及自定义优先级队列中元素如何[排序](https://www.cnblogs.com/huashanqingzhu/p/11040390.html)。对于 `pair` 类型的数据，先比较第一个，如果相等在比较第二个。
11. 第 767 题，重构字符串。其实是哈希的应用，先记录每个单词出现的频率。如果最大频率超过了长度的一半，无法重构。而后，按照每个单词出现的次数，分散排列开，先插入到奇数，而后插入偶数，保证相邻单词不同。
12. 第 719 题，找出第 k 小的距离对。用堆超时，但看不懂其它答案。学完二分在回来看吧。
13. 第 215 题，数组中的第K个最大元素。送分题。
14. 第 23 题，合并K个升序链表。使用优先级队列，先压入每个队列的第一个元素。而后当队列非空，依次弹出队列最小的元素。假设这个元素来自第二个链表，就压入第二个链表的下一个元素。以此类推。
15. 第 857 题，雇佣 K 名工人的最低成本。堆的应用，先创建`pair<单价，质量>`，按单价排序。之后创建队列，压入之前按单价排序的数组。当满足数量时，用最后压入的单价乘以累积的数量，保证给所有人开出高于期望的工资。