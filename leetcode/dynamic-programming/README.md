### 300 题，最长递增子序列

注意，子序列不连续，子串才连续。设置 dp 数组，dp 数组的状态来自之前的状态，所以双重循环：`dp[i] = max(dp[i], dp[j] + 1)`，`dp[j]` 表示之前的状态，+1 表示选择了第 i 个节点。最后求 dp 数组中的最大值即可。

此外需要注意的是，dp[i] 的初始值即 base case 为 1。

### 509 题，斐波那契数列

第一种方案是带备忘录的递归，避免重复的计算已经出现的数值。直接将结果赋值给 map，如果已经计算过，则直接返回。

第二种方案是动态规划，写出状态转移方程给 dp 数组赋值，这样，程序结束的时候直接返回 dp[N]。

### 322 题，零钱兑换

初始化的时候，要注意 base case，dp[0]=0，也就是 0 块钱不需要计数，之后的数组的初始化值设置的很大，如果说最终结果和最大值相等，说明无解。

之后进行状态转移，设 dp[i] 表示凑够 i 元钱所需的最少硬币，那么开始转移。如果所需要的钱大于面值，那么当前所需的最少硬币要么是当前的最小值，要么是上一状态 +1，为什么 +1 呢？因为所需的钱大于面值，准备一个硬币就好。而上一状态就是当前硬币减去当前面额。

### 931 题，下降的路径最小和

base case 为 dp 第一行的取值是矩阵的第一行，之后进行状态转移即可，需要注意的是，最小值是最后一行的最小值，而不是 dp 的最后一个元素。

### 494 题，目标和

这个题很有意思，记录一下收获。

1. 如果是简单的无返回参数的回溯，那么会超时，时间复杂度是回溯树的节点数，也就是 2^N。
2. 所以需要对回溯进行剪枝处理，设置回溯函数的返回参数并设置备忘录。如果有一个状态被计算过，那么就不用展开回溯树。状态设置为字符串，中间插入特殊字符帮正不会重复。其中的状态就是：idx 和当前累积和所组成的字符串。函数的返回值也就是 base case 为：如果遍历到数组末尾，判断当前运算是否满足条件，返回 1，表示有一种方案，否则返回 0。那么当前选择的方案数就是 nums[i] + nums[i+1] 或者 nums[i] - nums[i+1] 这两者的和。

### 72 题，最小编辑距离

我也是没想到，这么难的题，思路却很简单。如果编辑一个字符串，使这个字符串和另一个字符串相等。如果两个字符串不等，无非有三种操作：

1. 插入，在当前位置插入一个字符串，和目标字符串相等。此时目标字符串向后移动
2. 删除，删除当前位置的字符串，和目标字符串相等。此时编辑字符串向后移动
3. 替换，两者同时向后移动

如果两个字符串相等，两者同时向后移动。这样，比较三种方案哪个最省事就好。如果是自顶向下的分治递归，需要建立备忘录，否则超时。如果是自底向下的动态规划，就需要设置初始状态然后逐步转移：

1. 设 dp[i][j] 表示字符串的前 i 个转换到字符串的前 j 个的最短编辑距离。因为当前状态来自之前的状态，所以动态数组要比字符串的长度大 1
2. 初始状态为：dp 数组的第一行逐步累加，第一列也是逐步累加
3. 状态转移时，和回溯不同的是，当一个字符串处理完后，回溯需要往后看，dp 处理字符串得到的状态来自上一个状态 + 1。因此从 1 开始遍历，如果是插入，则 dp[i][j-1] + 1，删除的话则相反。
