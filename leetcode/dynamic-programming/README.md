### 300 题，最长递增子序列

注意，子序列不连续，子串才连续。设置 dp 数组，dp 数组的状态来自之前的状态，所以双重循环：`dp[i] = max(dp[i], dp[j] + 1)`，`dp[j]` 表示之前的状态，+1 表示选择了第 i 个节点。最后求 dp 数组中的最大值即可。

此外需要注意的是，dp[i] 的初始值即 base case 为 1。

### 509 题，斐波那契数列

第一种方案是带备忘录的递归，避免重复的计算已经出现的数值。直接将结果赋值给 map，如果已经计算过，则直接返回。

第二种方案是动态规划，写出状态转移方程给 dp 数组赋值，这样，程序结束的时候直接返回 dp[N]。

### 322 题，零钱兑换

初始化的时候，要注意 base case，dp[0]=0，也就是 0 块钱不需要计数，之后的数组的初始化值设置的很大，如果说最终结果和最大值相等，说明无解。

之后进行状态转移，设 dp[i] 表示凑够 i 元钱所需的最少硬币，那么开始转移。如果所需要的钱大于面值，那么当前所需的最少硬币要么是当前的最小值，要么是上一状态 +1，为什么 +1 呢？因为所需的钱大于面值，准备一个硬币就好。而上一状态就是当前硬币减去当前面额。

### 931 题，下降的路径最小和

base case 为 dp 第一行的取值是矩阵的第一行，之后进行状态转移即可，需要注意的是，最小值是最后一行的最小值，而不是 dp 的最后一个元素。

### 494 题，目标和

这个题很有意思，记录一下收获。

1. 如果是简单的无返回参数的回溯，那么会超时，时间复杂度是回溯树的节点数，也就是 2^N。
2. 所以需要对回溯进行剪枝处理，设置回溯函数的返回参数并设置备忘录。如果有一个状态被计算过，那么就不用展开回溯树。状态设置为字符串，中间插入特殊字符帮正不会重复。其中的状态就是：idx 和当前累积和所组成的字符串。函数的返回值也就是 base case 为：如果遍历到数组末尾，判断当前运算是否满足条件，返回 1，表示有一种方案，否则返回 0。那么当前选择的方案数就是 nums[i] + nums[i+1] 或者 nums[i] - nums[i+1] 这两者的和。
