### 300 题，最长递增子序列

注意，子序列不连续，子串才连续。设置 dp 数组，dp 数组的状态来自之前的状态，所以双重循环：`dp[i] = max(dp[i], dp[j] + 1)`，`dp[j]` 表示之前的状态，+1 表示选择了第 i 个节点。最后求 dp 数组中的最大值即可。

### 509 题，斐波那契数列

第一种方案是带备忘录的递归，避免重复的计算已经出现的数值。直接将结果赋值给 map，如果已经计算过，则直接返回。

第二种方案是动态规划，写出状态转移方程给 dp 数组赋值，这样，程序结束的时候直接返回 dp[N]。

### 322 题，零钱兑换

初始化的时候，要注意 base case，dp[0]=0，也就是 0 块钱不需要计数，之后的数组的初始化值设置的很大，如果说最终结果和最大值相等，说明无解。

之后进行状态转移，设 dp[i] 表示凑够 i 元钱所需的最少硬币，那么开始转移。如果所需要的钱大于面值，那么当前所需的最少硬币要么是当前的最小值，要么是上一状态 +1，为什么 +1 呢？因为所需的钱大于面值，准备一个硬币就好。而上一状态就是当前硬币减去当前面额。
