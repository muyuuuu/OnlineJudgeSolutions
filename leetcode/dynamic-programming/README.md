### 300 题，最长递增子序列

注意，子序列不连续，子串才连续。设置 dp 数组，dp 数组的状态来自之前的状态，所以双重循环：`dp[i] = max(dp[i], dp[j] + 1)`，`dp[j]` 表示之前的状态，+1 表示选择了第 i 个节点。最后求 dp 数组中的最大值即可。

此外需要注意的是，dp[i] 的初始值即 base case 为 1。

### 509 题，斐波那契数列

第一种方案是带备忘录的递归，避免重复的计算已经出现的数值。直接将结果赋值给 map，如果已经计算过，则直接返回。

第二种方案是动态规划，写出状态转移方程给 dp 数组赋值，这样，程序结束的时候直接返回 dp[N]。

### 322 题，零钱兑换

初始化的时候，要注意 base case，dp[0]=0，也就是 0 块钱不需要计数，之后的数组的初始化值设置的很大，如果说最终结果和最大值相等，说明无解。

之后进行状态转移，设 dp[i] 表示凑够 i 元钱所需的最少硬币，那么开始转移。如果所需要的钱大于面值，那么当前所需的最少硬币要么是当前的最小值，要么是上一状态 +1，为什么 +1 呢？因为所需的钱大于面值，准备一个硬币就好。而上一状态就是当前硬币减去当前面额。

### 931 题，下降的路径最小和

base case 为 dp 第一行的取值是矩阵的第一行，之后进行状态转移即可，需要注意的是，最小值是最后一行的最小值，而不是 dp 的最后一个元素。

### 494 题，目标和

这个题很有意思，记录一下收获。

1. 如果是简单的无返回参数的回溯，那么会超时，时间复杂度是回溯树的节点数，也就是 2^N。
2. 所以需要对回溯进行剪枝处理，设置回溯函数的返回参数并设置备忘录。如果有一个状态被计算过，那么就不用展开回溯树。状态设置为字符串，中间插入特殊字符帮正不会重复。其中的状态就是：idx 和当前累积和所组成的字符串。函数的返回值也就是 base case 为：如果遍历到数组末尾，判断当前运算是否满足条件，返回 1，表示有一种方案，否则返回 0。那么当前选择的方案数就是 nums[i] + nums[i+1] 或者 nums[i] - nums[i+1] 这两者的和。

### 72 题，最小编辑距离

我也是没想到，这么难的题，思路却很简单。如果编辑一个字符串，使这个字符串和另一个字符串相等。如果两个字符串不等，无非有三种操作：

1. 插入，在当前位置插入一个字符串，和目标字符串相等。此时目标字符串向后移动
2. 删除，删除当前位置的字符串，和目标字符串相等。此时编辑字符串向后移动
3. 替换，两者同时向后移动

如果两个字符串相等，两者同时向后移动。这样，比较三种方案哪个最省事就好。如果是自顶向下的分治递归，需要建立备忘录，否则超时。如果是自底向下的动态规划，就需要设置初始状态然后逐步转移：

1. 设 dp[i][j] 表示字符串的前 i 个转换到字符串的前 j 个的最短编辑距离。因为当前状态来自之前的状态，所以动态数组要比字符串的长度大 1
2. 初始状态为：dp 数组的第一行逐步累加，第一列也是逐步累加
3. 状态转移时，和回溯不同的是，当一个字符串处理完后，回溯需要往后看，dp 处理字符串得到的状态来自上一个状态 + 1。因此从 1 开始遍历，如果是插入，则 dp[i][j-1] + 1，删除的话则相反。

### 53 题，最大子序和

这个题比较简单，选择一个子序列，它的和是最大的。dp[i] 表示第 i 个子序列的和的最大值，当前状态要么是 nums[i] 自成一派，要么是来自上一个状态 dp[i-1]+nums[i]。dp[0]=nums[0]。

### 354 题，俄罗斯套娃

也就是看最多能在一个信封里面放多少信封，首先对宽度进行升序排列，若宽度相同，则按高度降序排列。最后选择高度的最大递增子序列即可。

这是因为，宽度已经升序了，如果选择高度的最大递增子序列，由于高度是降序的，所以不会选择同一个宽度的信封。

### 1143 题，最长公共子序列

这个题最开始我没有找到正确的转移方程和初始状态：

- 初始状态：也就是 dp 的第一行和第一列，遇到相同的字符时，后面的都是 1，并非只有单个 1。
- 转移：如果字符相等，当前状态就是上一状态 + 1，否则就是上一状态。然后相邻状态中取出最大值，相邻状态有 dp[i-1][j] 和 dp[i][j-1]。

### 416 题，分割等和的子集

- 回溯超时。这个题不能设置备忘录，因为当前索引，当前和，放入下一个和不放下一个都行，不是重复子状态。
- 转换为动态规划的背包问题，dp 数组的大小时常是个问题。以这个题为例，dp[i][j] 表示 i 个包是否能装下 j 个重量的物品，那么数组的大小就是nums.size(), target+1。因为最多也就是 nums.size() 个包，而列必须是 target+1，因为要看能否装下 target，访问的肯定是 dp[i][target]，所以要 +1。

### 583 题，兑换零钱

当物品数量不限制时，会变成完全背包问题。此时设置 dp[i][j] 的含义为：i 个物品装满 j 个容量的最多方法。

因此和传统背包不同的是，传统背包转移时要取出最大值，这里要求和。

此外再说一下 dp 数组大小设置的原则，建议直接设置为 n+1，m+1，省得出错。

### 64 题，地图上的最短路径

这个是传统的动态规划问题，路径的初始化只有左上角一个点。转移时，算一下都可以从哪些点到当前点即可。

### 174 题，地下城游戏

当动态规划的路径受到两个因素的影响时，可以尝试从结尾到开头进行反规划。如这个题，可以设置 dp[i][j] 表示从 [i][j] 到结尾时所需的最少体力，从末尾开始规划。[i][j] 的状态来自右侧或下侧的最小值，如果当前格子要扣血，那么就加上要扣血的值，如果当前格子回血，就减去回血的值。如果值是负数，表示回血很猛，这个格子只需要 1 的体力值就可以到达末尾。

### 887 题，扔鸡蛋

这个题需要换个思路，一时间不知道我是背过了还是理解了：

1. 设 dp[i][j] 表示 i 次测试 j 个鸡蛋，能测到的楼层数
2. 那么遍历的时候，内部循环得是鸡蛋数，这样，次数逐步累加，看看能用这些鸡蛋测到多少层楼
3. 转移时，分为两种情况，鸡蛋没碎，那么 dp[i][j] = dp[i-1][j]；鸡蛋碎了，那么 dp[i][j] = dp[i-1][j-1] + 1。无论如何，都消耗了一步
4. 如果当前次数大于层数，返回次数；否则，最后返回楼层数，因为这是最大的情况
