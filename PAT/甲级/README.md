之前刷了60多道，暂时先整理后刷的，不然一次性整理150道有点费劲。

| 题目类型 | 题目 |
| -------- | ---- |
| 素数 | 1015 |
| 数据精度 | 1058，1065，1081|
| 数组应用 | 1046，1042，1029(选择中位数)，1117，1067，1113，1128(N皇后判断)，1125，1082(极度繁琐，我抄的)，1002，1008，1009(与1002类似)，1011，1019，1041，1045，1046，1048，1054，1085，1109，1148|
| 字符串处理 | 1035(`vector`应用)，1073，1069(字符串转数字)，1077(最大公共后缀子串)，1140，1136，1108，1120，1001，1005，1006，1023，1024，1027，1031，1035，1042，1061，1069，1073，1084，1092，1093(子串匹配)，1100，1108，1112，1116，1120，1132|
| 数学计算 | 1096，1104，1113，1117|
| `map`应用 | 1041(可哈希)，1144(不可哈希)，1124，1112，1121，1149，1022，1071|
| 哈希算法 | 1041(可`map`)，1121，1145(正宗哈希)，1050，1078(正宗哈希)|
| 数据精度 | 1088，1136(写字符串加法) |
| `vector`应用 | 1048 |
| 借助结构体的多条件排序 | 1025，1012，1028，1047，1055，1062，1075，1083，1070，1036，1141，1137，1153，1070|
| 排序算法 | 1089(插入与归并)，1101(快速排序) |
| 栈的应用 | 1051|
| 树状数组 | 1057(无序数据的中位数) |
| `set`应用 | 1129(操作符重载)，1063|
| 动态规划 | 1040(最长对称子串)，1044，1045，1007(子序列和最大)|  
| 队列应用 | 1017 |
| 链表处理 | 1028，1032，1133，1052，1074，1097|
| 树的应用 | 1004(层次遍历二叉树，输出叶子节点)，1102(层次、右根左遍历，反转二叉树)，1043(查找树、镜像查找树、先序、后序)，1064(完全查找树)，1099(按指定结构建立二叉查找树)，1110(判断完全二叉树，第六个测试点测评机器有问题)，1123(AVL树的层序遍历与判断是否是完全二叉树)，1066(寻找AVL树的根)，1130(中缀表达式)，1020(前序后序转层序)，1053(遍历树，求权重相等的路径)，1076(宽度优先遍历)，1079(深优遍历叶子节点)，1090(叶子节点数量)，1094(树中最长路径)，1106(树中最长路径与叶子数量)，1115(建立二叉查找树)|
| 图的应用 | 1154(相邻顶点颜色是否相同)，1146(有向图的拓扑序列)，1122(哈密顿图的判断)，1134(无向图的顶点覆盖)，1142(极大团问题)，1126(欧拉回路)，1013(连通分量计数)，1021(计数图内最长路径，连通子图计数) |
| 最短路径 | 1030(借助遍历)，1003(最短路径数量与点权求和)，|
| 进制转换 | 1010 |
| 三维遍历 | 1091(dfs算法遍历三维数据) |
| 旋转矩阵 | 1105 |
| 并查集 | 1107，1114，1118|


## 记录

1. `vector<int> a(10, 1)`的含义为声明一个长度为10的不定长数组且全部初始化为 1 。
2. 当借助结构体的多条件排序需要比较的条件比较多时，可以考虑结构体中放数组。甲级1012。
3. 求两个递增序列的中位数，直接`sort`会超时，且有更好的算法，提前计算中位数的位置即可。甲级1029。
4. 运算的括号可能会加长运算时间而超时，也可考虑更换`cin`为`scanf`，`cout`为`printf`。甲级1055。
5. 在使用`map`时，查找无效表示为0，所以在设立映射时的初始值应该为1而不是0。甲级1137。
6. 简易判断完全二叉树的方法。甲级`1110-1.cpp`。

## 待解决

1067 的交换0排序算法

1044 的动态规划算法

1045 为何顺序计数不对

AVL树相关

1057 树形数组

1049 中 1 的计数